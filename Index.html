<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>我的Vue学习Demo首页</title>
    <link rel="stylesheet" href="prism.css"/>
    <style type="text/css">
        div,p,span{
            font-size:11px;
        }
        li{
            line-height: 25px;
        }
        .demo {
            border: 1px solid #d6dde3;
            background: #ede9ed;
            min-height: 100px;
            width: 600px;
            margin: 10px 0 0 20px;
            padding: 10px 10px 10px 20px;
            line-height: 30px;
        }

        .title {
            font-size: 16px;
            font-weight: bold;
            margin-left: 20px;
        }

        .red {
            color: red;
        }

        .highlighting{
            color: #ffb02a;
            background: #e3e7d5;
            font-family: Verdana;
            padding: 2px;
        }

        pre code {
            margin:0;
            padding:0;
        }

       .demo p.tip {
        padding: 12px 24px 12px 30px;
        margin: 2em 0;
        border-left: 4px solid #f66;
        background-color: #f8f8f8;
        position: relative;
        border-bottom-right-radius: 2px;
        border-top-right-radius: 2px;
    } 

        .demo p.tip:before {
        position: absolute;
        top: 14px;
        left: -12px;
        background-color: #f66;
        color: #fff;
        content: "!";
        width: 20px;
        height: 20px;
        border-radius: 100%;
        text-align: center;
        line-height: 20px;
        font-weight: bold;
        font-family: 'Dosis', 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;
        font-size: 14px;
    }

    </style>
</head>
<body>
<a name="Dictionary"></a>
</br>
<h1>我的Vue学习Demo</h1>
<h2>目录</h2>
<ul>
    <li><a href="#FirstDemo">Hello World!</a></li>
    <li><a href="#For">渲染列表</a></li>
    <li><a href="#ReserveMessage">处理用户输入</a></li>
    <li><a href="#Total">综合</a></li>
    <li><a href="#If">if指令</a></li>
    <li><a href="#VmPropertity">vm实例的属性和方法</a></li>
    <li><a href="#LifeCycle">vm实例的生命周期</a></li>
    <li><a href="#DataBind">数据绑定</a></li>
    <li><a href="#DataFilter">过滤器、指令、缩写</a></li>
    <li><a href="#Computed">计算属性</a></li>
    <li><a href="#ClassStyle">Class与Style绑定</a></li>
</ul>
<h2>Demo</h2>

<!-- 第一个Demo：双向绑定 ---开始-->
<a name="FirstDemo"></a>
<h3 class="title">#第一个Demo：双向绑定</h3>
<div class="demo">
    <div id="FirstDemo">
        <input v-model="Message" type="text"/></br>
        <p>{{Message}}</p>
    </div>
</div>
<!-- 第一个Demo：双向绑定 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- 渲染列表 ---开始-->
<a name="For"></a>
<h3 class="title">#渲染列表</h3>
<div class="demo">
    <div id="For">
        <ul>
            <li v-for="item in list">
                {{item}}
            </li>
        </ul>
    </div>
    <p class="red">注：这里的list必须是数组对象！</p>
    <p class="red">另：其中一个指令解析出错，所有指令都不执行！</p>
</div>
<!-- 渲染列表 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- 处理用户输入 ---开始-->
<a name="ReserveMessage"></a>
<h3 class="title">#处理用户输入</h3>
<div class="demo">
    <div id="ReserveMessage">
        <p>{{Message}}</p>
        <button v-on:click="reserveMessage">Reserve Message</button>
    </div>
</div>
<!-- 处理用户输入 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- 综合 ---开始-->
<a name="Total"></a>
<h3 class="title">#综合</h3>
<div class="demo">
    <div id="Total">
        <input type="text" v-on:keyup.enter="AddTodo" placeholder="Keyup Enter to add item" v-Model="newTodo"/>
        <ul>
            <li v-for="todo in Todos">
                <span>{{todo.Text}}</span>
                <button v-on:click="RemoveTodo($index)">X</button>
            </li>
        </ul>
    </div>
</div>
<!-- 综合 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- if指令 ---开始-->
<a name="If"></a>
<h3 class="title">#if指令</h3>
<div class="demo">
    <div id="If">
        <span v-if="greeting">Hello!</span>
    </div>
</div>
<!-- if指令 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- vm实例的属性和方法 ---开始-->
<a name="VmPropertity"></a>
<h3 class="title">#vm实例的属性和方法</h3>
<div class="demo">
    <div id="VmPropertity">
        <ul>
            <li>一个Vue的实例其实正是一个MVVM模式中的ViewModel-因此后可经常使用vm这个变量名</li>
            <li>在实例化Vue时,需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等</li>
            <li>可以扩展Vue构造器，从而用预定义的选项创建可复用的组件构造器</li>
            <li>组件其实都是被扩展的Vue实例</li>
        </ul>
        <h4>属性与方法</h4>
        <p>每个Vue的实例都会代理其<span class="highlighting">data</span>对象里所有的属性</p>
        <pre>
            <code class="language-javascript">
var data = { a: 1 }
var vm = new Vue({
data: data
})

vm.a === data.a // -> true

// 设置属性也会影响到原始数据
vm.a = 2
data.a // -> 2

// ... 反之亦然
data.a = 3
vm.a // -> 3
            </code>
        </pre>
        <p>除了数据属性，Vue实例暴露了一些有用的实例属性和方法，这些属性与方法都有前缀$,以便与代理的数据属性区分。</p>
        <pre>
            <code class="language-javascript">
var data = {a:1};
var vm = new Vue({
el:'#example',
data:data
});

vm.$data === data // -> true
vm.$el === document.getElementById('example') // -> true

// $watch 是一个实例方法
vm.$watch('a',function(newVal,oldVal){
    // 这个回调将在 'vm.a' 改变后调用
});
            </code>
        </pre>
    </div>
</div>
<!-- vm实例的属性和方法 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- vm实例的生命周期 ---开始-->
<a name="LifeCycle"></a>
<h3 class="title">#vm实例的生命周期</h3>
<div class="demo lifeCycle">
    <div id="LifeCycle">
        <p>下图说明了vm实例的生命周期</p>
        <img src="http://cn.vuejs.org/images/lifecycle.png" style="width:560px">
        <p>{{createdTime}}</p>
        <p>{{beforeCompileTime}}</p>
        <p>{{compiledTime}}</p>
        <p>{{readyTime}}</p>
        <p>{{beforeDestroyTime}}</p>
        <p>{{destroyedTime}}</p>
    </div>
</div>
<!-- vm实例的生命周期 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- 数据绑定 ---开始-->
<a name="DataBind"></a>
<h3 class="title">#数据绑定</h3>
<div class="demo">
    <div id="DataBind">
        <h4>文本</h4>
        <p>数据绑定最基础的形式是文本插值，使用“Mustache”语法（双大括号）</p>
        <span>Message: {{ msg }}</span>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<span>Message: {{ msg }}</span>
                </script>
            </code>
        </pre>
        <p>单次插值</p>
        <span>This will never change: {{* msg }}</span>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<span>This will never change: {{* msg }}</span>
                </script>
            </code>
        </pre>
        <button v-on:click="changeMsg">Change Msg</button>
        <p>JavaScript Code</p>
        <pre>
            <code class="language-javascript">
var dataBind = new Vue({
        el:"#DataBind",
        data:{
            msg:"This is the message"
        },
        methods:{
            changeMsg:function(){
                this.msg = "The message is changed!";
            }
        }
    });
            </code>
        </pre>
        </br>
        <h4>原始的HTML</h4>
        <p>使用三Mustache标签</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<div>{{{raw_html}}}</div>
                </script>
            </code>
        </pre>
        <h4>HTML特性</h4>
        <p>Mustache Mustache 标签也可以用在 HTML 特性 (Attributes) 内：</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<div id="item-{{ id }}"></div>
                </script>
            </code>
        </pre>
        <h4>JavaScript 表达式</h4>
        <p> Vue.js 在数据绑定内支持全功能的 JavaScript 表达式：</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}
                </script>
            </code>
        </pre>
        <p>一个限制是每个绑定只能包含单个表达式，因此下面的语句是无效的：</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<!-- 这是一个语句，不是一个表达式： -->
{{ var a = 1 }}

<!-- 流程控制也不可以，可改用三元表达式 -->
{{ if (ok) { return message } }}
                </script>
            </code>
        </pre>
    </div>
</div>
<!-- 数据绑定 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>

<!-- 数据过滤 ---开始-->
<a name="DataFilter"></a>
<h3 class="title">#过滤器、指令、缩写</h3>
<div class="demo">
    <div id="DataFilter">
    <h4>过滤器</h4>
       <p>Vue.js 允许在表达式后添加可选的“过滤器”，以管道符指示：</p>
       <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
{{ message | capitalize }}
                </script>
            </code>
        </pre>
        <p>过滤器可以串联：</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
{{ message | filterA | filterB }}
                </script>
            </code>
        </pre>
        <p>过滤器也可以接受参数：</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
{{ message | filterA 'arg1' arg2 }}
                </script>
            </code>
        </pre>
        <p>过滤器函数始终以表达式的值作为第一个参数。带引号的参数视为字符串，而不带引号的参数按表达式计算。这里，字符串 'arg1' 将传给过滤器作为第二个参数，表达式 arg2 的值在计算出来之后作为第三个参数。</p>
        <h4>指令</h4>
        <p>指令（Directives)是特殊的带有前缀<span class='highlighting'>v-</span>的物性,指令的值限定为绑定表达式，因此上面提到的Javascript表达式及过滤器规则 在这里也适用。指令的职责就是当其表达式的值改变时把某些特殊的行为应用到DOM上。</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<p v-if="greeting">Hello!</p>
                </script>
            </code>
        </pre>
        这里 <span class="highlighting">v-if</span> 指令将根据表达式 <span class="highlighting">greeting</span>  值的真假删除/插入 <span class="highlighting">&lt;p&gt;</span> </span>元素。
        <h5>#参数</h5>
        <p>有些指令可以在其名称后面带一个"参数"(Argument),中间放一个冒号隔开。例如,<span class="highlighting">v-bind</span>指令用于响应地更新HTML特性：</p>
        <pre>
            <code class="language-markup">
                <script type = "prism-html-markup">
<a v-bind:href = "url"></a>
                </script>
            </code>
        </pre>
        <h5>#修饰符</h5>
        <p>修饰符（Modifiers）是以半角句号<span class="highlighting">.</span>开始的特殊后缀，用于表示指令应当以特殊方式绑定。例如<span class="highlighting">.literal</span>修饰符告诉指令将它的值解析为一个字面字符串而不是一个表达式：</p>
        <pre>
            <code class="language-markup">
                <script type = "prism-html-markup">
<a v-bind:href.literal="/a/b/c"></a>
                </script>
            </code>
        </pre>
        <h5>缩写</h5>
        <h4>#<span class="highlighting">v-bind</span> 缩写</h4>
        <pre>
            <code class="language-markup">
                <script type = "prism-html-markup">
<!-- 完整语法 -->
<a v-bind:href="url"></a>

<!-- 缩写 -->
<a :href="url"></a>

<!-- 完整语法 -->
<button v-bind:disabled="someDynamicCondition">Button</button>

<!-- 缩写 -->
<button :disabled="someDynamicCondition">Button</button>
                </script>
            </code>
        </pre>
        <h5><span class="highlighting">#v-on</span> 缩写</h5>
<pre>
            <code class="language-markup">
                <script type = "prism-html-markup">
<!-- 完整语法 -->
<a v-on:click="doSomething"></a>

<!-- 缩写 -->
<a @click="doSomething"></a>
                </script>
            </code>
        </pre>
    </div>
</div>
<!-- 数据过滤 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>


<!-- 计算属性 ---开始-->
<a name="Computed"></a>
<h3 class="title">#计算属性</h3>
<div class="demo">
    <div id="Computed">
       a={{ a }}, b={{ b }}
       <h4>#基础例子</h4>
       <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<div id="example">
  a={{ a }}, b={{ b }}
</div>
                </script>
            </code>
       </pre>
       <pre>
            <code class="language-javascript">
var computed = new Vue({
        el:"#Computed",
        data:{
            a:1
        },
        computed:{
            // 一个计算属性的 getter
            b:function(){
                // 'this'指向vm实例
                return this.a+1;
            }
        }
    });
            </code>
       </pre>
       <p>结果：</p>
       <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
  a=1, b=2
                </script>
            </code>
       </pre>
       <pre>
            <code class="language-javascript">
console.log(vm.b) // -> 2
vm.a = 2
console.log(vm.b) // -> 3
            </code>
       </pre>
       <h4>#计算属性vs.$watch</h4>
       <p>Vue.js 提供了一个方法 $watch，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， $watch 很诱人 —— 特别是如果你来自 AngularJS。不过，通常更好的办法是使用计算属性而不是一个命令式的 $watch 回调。考虑下面例子：</p>
        <pre>
            <code class="language-markup">
                <script type="prism-html-markup">
<div id="demo">{{fullName}}</div>
                </script>
            </code>
       </pre>
       <pre>
            <code class="language-javascript">
var vm = new Vue({
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  }
})

vm.$watch('firstName', function (val) {
  this.fullName = val + ' ' + this.lastName
})

vm.$watch('lastName', function (val) {
  this.fullName = this.firstName + ' ' + val
})
            </code>
       </pre>
       <p>上面代码是命令式的重复的。跟计算属性对比</p>
        <pre>
            <code class="language-javascript">
var vm = new Vue({
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
            </code>
       </pre>

       <h5>#计算setter</h5>
      <div> 
      firstName: {{firstName}}</br>
       lastName: {{lastName}}</br>
       fullName: {{fullName}}</br>
        </div>
        <p>计算属性默认只是 getter，不过在需要时你也可以提供一个 setter：</p>
                <pre>
            <code class="language-javascript">
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
            </code>
       </pre>
    </div>
</div>
<!-- 计算属性 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>


<!-- Class与 Style绑定 ---开始-->
<a name="ClassStyle"></a>
<h3 class="title">#Class与 Style绑定</h3>
<div class="demo">
    <div id="ClassStyle">
        <p>数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性，我们可以用 v-bind 处理它们：我们只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在v-bind 用于 class 和 style 时，Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。</p>
        <h4>绑定 HTML Class</h4>
        <p class="tip">
            尽管可以用 Mustache 标签绑定 class，比如 class="{{ className }}"，但是我们不推荐这种写法和 v-bind:class 混用。两者只能选其一！
        </p>
        <h5>#对象语法</h5>
        <p>我们可以传给 <span class="highlighting">v-bind:class</span> 一个对象，以动态地切换 class。注意 <span class="highlighting">v-bind:class</span> 指令可以与普通的 <span class="highlighting">class</span> 特性共存：</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div class="static" v-bind:class="{ 'class-a': isA, 'class-b': isB }"></div>
            </script>
            </code>
        </pre>
        <pre>
            <code class="language-javascript">
data: {
  isA: true,
  isB: false
}
            </code>
        </pre>
        <p>渲染为：</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div class="static class-a"></div>
            </script>
            </code>
        </pre>
        <p>当 isA 和 isB 变化时，class 列表将相应地更新。例如，如果 isB 变为 true，class 列表将变为 "static class-a class-b"。</p>
        <p>也可以直接绑定数据里的一个对象</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div v-bind:class="classObject"></div>
            </script>
            </code>
        </pre>
         <pre>
            <code class="language-javascript">
data: {
  classObject: {
    'class-a': true,
    'class-b': false
  }
}
            </code>
        </pre>
        <p>我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式。</p>
        <h5>#数组语法</h5>
        <p>也可以把一个数组传给<span class="highlighting">v-bind:class</span>,以应用一个class列表</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div v-bind:class="[classA,classB]"></div>
            </script>
            </code>
        </pre>
         <pre>
            <code class="language-javascript">
data: {
    classA:'class-a',
    classB:'class-b'
}
            </code>
        </pre>
        <p>渲染为：</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div class="class-a class-b"></div>
            </script>
            </code>
        </pre>
        <p>如果你也想根据条件切换列表中的class,可以用三元表达式</p>
<pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div v-bind:class="[classA, isB ? classB : '']">
            </script>
            </code>
        </pre>
        <p>此例始终添加 <span class="highlighting">classA</span>，但是只有在 <span class="highlighting">isB</span> 是 <span class="highlighting">true</span> 时添加 <span class="highlighting">classB</span> 。</p>
        <p>不过，当有多个条件 class 时这样写有些繁琐。在 1.0.19+ 中，可以在数组语法中使用对象语法：</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div v-bind:class="[classA, { classB: isB, classC: isC }]">
            </script>
            </code>
        </pre>
        <h4>绑定内联样式</h4>
        <h5>对象语法</h5>
        <p><span class="highlighting">v-bind:style </span>的对象语法十分直观——看着非常像 CSS，其实它是一个 JavaScript 对象。CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：</p>
        <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
            </script>
            </code>
        </pre>
        <pre>
            <code class="language-javascript">
data: {
  activeColor: 'red',
  fontSize: 30
}
            </code>
        </pre>
        <p>直接绑定到一个样式对象通常更好，让模板更清晰：</p>
                <pre>
            <code class="language-markup">
            <script type="prism-html-markup">
<div v-bind:style="styleObject"></div>
            </script>
            </code>
        </pre>
        <pre>
            <code class="language-javascript">
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
            </code>
        </pre>
        <h5>#数组语法</h5>
        <p><span class="highlighting">v-bind:style</span>的数组语法可以将多个样式对象应用到一个元素上</p>
        <pre>
            <code class="language-markup">
                    <script type="prism-html-markup">
<div v-bind:style="[styleObjectA,styleObjectB]">
                    </script>
            </code>
        </pre>
        <h5>#自动添加前缀</h5>
         <p>当<span class="highlighting">v-bind:style</span>使用需要厂商前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。</p>
    </div>
</div>
<!-- Class与 Style绑定 ---结束-->
</br>
<span><a href="#Dictionary">回目录</a></span>
</br>

</body>
<script type="text/javascript" src="prism.js"></script>
<script type="text/javascript" src="vue.js"></script>
<script type="text/javascript">
    // #第一个Demo：双向绑定
    var fd = new Vue({
        el: "#FirstDemo",
        data: {
            Message: "Hello World!"
        }
    });

    //#渲染列表
    var theFor = new Vue({
        el: "#For",
        data: {
            list: [
                "First",
                "Second",
                "Third",
                "Fourth"
            ]
        }
    });

    //#处理用户输入
    var reserveMessage = new Vue({
        el: "#ReserveMessage",
        data: {
            Message: "Hello VueJs!"
        },
        methods: {
            reserveMessage: function () {
                this.Message = this.Message.split('').reverse().join('');
            }
        }
    });

    //#综合
    var total = new Vue({
        el: "#Total",
        data: {
            newTodo: "",
            Todos: [
                {
                    Text: "Add some todo"
                }
            ]
        },
        methods: {
            AddTodo: function () {
                var text = this.newTodo.trim();
                this.Todos.push({
                    Text: text
                });
            },
            RemoveTodo: function (index) {
                this.Todos.splice(index, 1);
            }
        }
    });

    //#if指令
    var theIf = new Vue({
        el: "#If",
        data: {
            greeting: true
        }
    });
    var number = 0;

    //#vm实例的生命周期
    var lifeCycle = new Vue({
        el:"#LifeCycle",
        data:{
            createdTime:"createdTime",
            beforeCompileTime:"beforeCompileTime",
            compiledTime:"compiledTime",
            readyTime:"readyTime",
            beforeDestroyTime:"beforDestroyTime",
            destroyedTime:"destoryedTime"
        },
        created:function(){
            number++;
            this.createdTime = "createdTime: "+GetTime()+" order:"+number;
        },
        beforeCompile:function(){
            number++;
            this.beforeCompileTime = "beforeCompileTime: "+GetTime()+" order:"+number;
        },
        compiled:function(){
            number++;
            this.compiledTime = "compiledTime: "+GetTime()+" order:"+number;
        },
        ready:function(){
            number++;
            this.readyTime = "readyTime: "+GetTime()+" order:"+number;
        },
        beforeDestroy:function(){
            number++;
            this.beforeDestroyTime = "beforeDestroyTime: "+GetTime()+" order:"+number;
            //alert(this.beforeDestroyTime);
        },
        destroyed:function(){
            number++;
            this.destroyedTime = "destroyedTime: "+GetTime()+" order:"+number;
            //alert(this.destroyedTime);
        }
    });
    //lifeCycle.$destroy(false);
    //var lifeCycleDemo = document.getElementsByClassName("lifeCycle");
    //lifeCycle.$mount(lifeCycleDemo);
    function GetTime(){
        var time = new Date();
        return time.getFullYear()+"年"+(time.getMonth()+1)+"月"+time.getDate()+"日 "
        +time.getHours()+":"+time.getMinutes()+":"+time.getSeconds()+" "+time.getMilliseconds()
        +"毫秒";
    }

    //数据绑定
    var dataBind = new Vue({
        el:"#DataBind",
        data:{
            msg:"This is the message"
        },
        methods:{
            changeMsg:function(){
                this.msg = "The message is changed!";
            }
        }
    });

    // 计算属性基础例子
    var computed = new Vue({
        el:"#Computed",
        data:{
            a:1,
            firstName: 'Foo',
            lastName: 'Bar',
            fullName: 'Foo Bar'
        },
        computed:{
            // 一个计算属性的 getter
            b:function(){
                // 'this'指向vm实例
                return this.a+1;
            },
            fullName:{
                get:function(){
                    return this.firstName + " "+ this.lastName;
                },
                set:function(val){
                    var names = val.split(" ");
                    this.firstName = names[0];
                    this.lastName = names[1];
                }
            }
        }
    });
//    computed.$watch('firstName', function (val) {
//      this.fullName = val + ' ' + this.lastName
//    });

 //   computed.$watch('lastName', function (val) {
//    this.fullName = this.firstName + ' ' + val
//  })
    

</script>
</html>